                            TASM USER'S MANUAL
        TASM - A Table Driven Cross Assembler for the MSDOS* Environment
                               Thomas N. Anderson
                         Speech Technology Incorporated
                              16321 176th Avenue NE
                             Woodinville, WA   98072
      
                                   March, 1986
                                   Version 2.2
      
      [Speech Technology Incorporated  is  a  manufacturer  of  electronic
      devices  to  aid  the visually impaired,  generally employing speech
      synthesis technology.]
      
      
      
      (C) Copyright 1985,  1986 by  Speech  Technology  Incorporated.  All 
      rights  reserved.  Permission  is  granted to copy this document and 
      related software.  
      
      
      If you are dissatisfied with the product for any reason,  return the
      original  merchandise (disk and manual) within 90 days to seller for
      a full refund of any amounts paid.
      
      
      
      
      
      
      
       * MSDOS is a trademark of Microsoft Corporation.
      
      
      
      

      TASM - Table Driven Assembler                                Page 2    
      
      
      TABLE OF CONTENTS
      
      
      
      
      
      
      
      
      
      
              SECTION                                        PAGE
              ____________________________________________________
              INTRODUCTION....................................3
              INVOCATION......................................4
              SOURCE FORMAT...................................7
              EXPRESSIONS.....................................9
              ASSEMBLER DIRECTIVES............................12
              OBJECT FILE FORMATS.............................18
              LISTING FILE FORMAT.............................20
              PROM PROGRAMMING................................21
              ERROR MESSAGES..................................23
              BUGS AND LIMITATIONS............................25
              6502 INSTRUCTIONS AND ADDRESSING MODES..........26
              8048 INSTRUCTIONS AND ADDRESSING MODES..........29
              8051 INSTRUCTIONS AND ADDRESSING MODES..........33
              TASM DISTRIBUTION FILES.........................37
              PORTING TASM TO OTHER ENVIRONMENTS..............38
              TASM INSTRUCTION SET TABLE DEFINITION...........40
              SUMMARY.........................................43
      
              APPENDIX A - SAMPLE LISTING FILE................44
              APPENDIX B - SAMPLE INSTRUCTION SET TABLE ......46
              APPENDIX C - ORDERING INFORMATION...............51
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      

      TASM - Table Driven Assembler                                Page 3    
      
      
      INTRODUCTION
      
      TASM is a set of  table  driven  cross  assemblers  for  the  MS-DOS
      environment.  Currently  versions  for  the  6502,  8048,  and  8051
      microprocessors are supported by STI,  but the user so inclined  may
      build versions for other 8 bit microprocessors (see sections on TASM
      DISTRIBUTION  FILES  and  TASM  INSTRUCTION SET TABLE DEFINITION for
      notes on reconfiguring TASM for other processors).
      
      TASM characteristics include:
      
              1.  Powerful expression parsing (17 operators).
      
              2.  Supports a subset of the 'C' preprocessor commands.
      
              3.  Macro capability (through use of DEFINE directive).
      
              4.  Multiple statements per line.
      
              5.  Supports three object file formats (Intel Hex, MOS
                      Technology Hex, and binary).
      
              6.  Absolute code generation only.
      
              7.  Source code available (in C).
      
              8.  Uniform syntax  across  versions  for  different  target
                      machines.
      
              9.  Features in support  of  PROM  programming  (preset  all
                      bytes  to  specified value,  output object code in a
                      contiguous block).
      
              10.  Supports extended instructions of the Rockwell R65C02.
      
              11.  Tables  can  be  generated  for  other  microprocessors
                      without having to modify the TASM executable module.
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      

      TASM - Table Driven Assembler                                Page 4    
      
      
      INVOCATION
      
      TASM can be invoked as  follows  (optional fields shown in brackets,
      symbolic fields enclosed in <>):
      
          tasm -<pn> [-bcfhlmpxdo] source_file [object_file [list_file]]
      
          Where the option flags are defined as follows:
      
              -<pn>           Specify version (<pn> = part number)
              -c              object file written as a contiguous block
              -f<xx>          Fill entire memory space with <xx> (hex)
              -h              Produce hex table of the assembled code
              -l              Produce a label table in the listing
              -m              Produce object in MOS Technology format
              -b              Produce object in binary (.COM) format
              -p              Page the listing file
              -q              Quite, disable the listing file
              -x[<m>]         Enable extended instruction set (if any)
              -d<macro>       Define a macro (or just a macro label)
              -o<bb>          Bytes per object record (hex)
      
      TASM has no built in instruction set tables,  and so  it  must  read
      them  at  run time.  TASM determines which table to use based on the
      '-<pn>' field shown above.  For example,  to assemble the code in  a
      file called 'source.asm' one would enter:
      
              tasm -48  source.asm            for an 8048 assembly
              tasm -65  source.asm            for a  6502 assembly
              tasm -51  source.asm            for a  8051 assembly.
      
      The file name that the tables are read from is formed by taking  the
      digits  specified  after  the  '-'  and  appending it to 'TASM' then
      appending the '.TAB' extension.  Thus,  the '-48' flag  would  cause
      the  tables  to  be  read from the file 'TASM48.TAB' (See section on
      TASM INSTRUCTION SET DEFINITION).
      
      The  source file must be specified.  If not,  some usage information
      is displayed.  If the object file is not specified then  the  object
      filename  is  formed  by taking the source filename and changing the
      extension  to  '.OBJ'.  Similarly,  if  the  list  filename  is  not
      specified  it is formed by changing the source filename extension to
      '.LST'.
      
      Each option flag must be  preceded  by  a  dash.  Options  need  not
      precede  the filenames,  however.  The various options are described
      below:
      
      c - Contiguous Block Output. If this option is specified,  then  all
      bytes  in the range from the lowest used byte to the highest will be
      defined in the object file.  Normally,  with the default  Intel  Hex
      object  format  enabled,  if  the Program Counter (PC) jumps forward
      because of an .ORG directive,  the bytes skipped over will not  have
      any  value  assigned  them  in  the  object  file.  With this option
      enabled,  no output to the object file occurs until the end  of  the
      assembly  at  which time the whole block is written.  This is useful

      TASM - Table Driven Assembler                                Page 5    
      
      when using TASM to generate code that will be put  into  a  PROM  so
      that  all  locations  will have a known value.  This option is often
      used in conjunction with the -f option to ensure  all  unused  bytes
      will have a known value.
      
      f  -  Fill  Memory.  This  option  causes the memory image that TASM
      maintains to be initialized to the value specified by  the  two  hex
      characters  immediately  following the 'f'.  TASM maintains a memory
      image that is a full 64K bytes in size (even if the target processor
      cannot  utilize  that  memory  space).  Invocation  of  this  option
      introduces a 2 second delay at start up (time required to initialize
      all 64K bytes).   See Appendix A for an example.
      
      h - Hex Table. This option causes a hex table of the produced object
      code to appear in the listing file.  Each line of  the  table  shows
      sixteen bytes of code.  The format is shown in the sample listing in
      Appendix A.
      
      l - Label Table. This option causes a label table to appear  in  the
      listing  file.  Each  label is  shown  with its corresponding value.
      Macro labels (as established  via  the  DEFINE  directives)  do  not
      appear.  The format is shown in the sample listing in Appendix A.
      
      m - MOS Technology Object Format. This option causes the object file
      to be written in MOS Technology hex format rather than  the  default
      Intel  hex  format.  See  section  on  OBJECT  FILE  FORMATS  for  a
      description of the format.
      
      b  -  Binary Object Format. This option causes the object file to be
      written in binary - one byte for each byte of code/data.  Note  that
      no  address  information  is  included  in  the  object file in this
      format.  The contiguous block (-c) output mode is forced  when  this
      option is invoked.
      
      p - Page Listing File.  This option causes the listing file to  have 
      top of page headers and form feeds inserted at appropriate intervals 
      (every sixty lines of output).  
      
      q - Disable Listing File.  This option  causes  all  output  to  the 
      listing  file  to  be  suppressed,   unless  a  .LIST  directive  is 
      encountered in the source file (see LIST/NOLIST directives).  
      
      x - Enable Extended Instruction  Set.  If  a  processor  family  has
      instructions  that  are valid for only certain members,  this option
      can be used to enable those beyond the  basic  standard  instruction
      set.  Presently,  this  option  only  has  significance for the 6502
      version (TASM -65) which has extended instructions for the  Rockwell
      R65C02  and  the  R65C00/21.  A  hex  digit  may  follow  the 'x' to
      indicate a mask value used in selecting the appropriate  instruction
      set.  Bit  0  of the mask selects the basic instruction set,  thus a
      '-x1' would have no effect.  A '-x3' would enable the basic set plus
      whatever instructions have bit 1 set in their  class  mask.  A  '-x'
      without  a  digit  following is equivalent to a '-xf' which sets all
      four of the  mask  bits.  (See  section  on  6502  INSTRUCTIONS  AND
      ADDRESSING MODES for details on its extended instructions).
      
      

      TASM - Table Driven Assembler                                Page 6    
      
      d - Define a Macro. Macros  are  be  defined  on  the  command  line
      generally to control the assembly of various IFDEF's that are in the
      source  file.  This is a convenient way to generate various versions
      of object code from a single source file.
      
      o - Set Number of Bytes per Object Record.  When  generating  object
      code in either the MOS Technology format or the Intel hex format,  a
      default of 24 (decimal) bytes of object are defined on each  record.
      This can be altered by invoking the '-o' option immediately followed
      by  two  hex digits defining the number of bytes per record desired.
      For example,  if 32 bytes per record are desired,  one might  invoke
      TASM as:
      
              TASM -48 -o20 source.asm
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      

      TASM - Table Driven Assembler                                Page 7    
      
      
      SOURCE FORMAT
      
      Statements in the source file must conform to a  format  as  follows
      (except  for assembler directive statements which are described in a
      subsequent section):
      
              <label>  <operation>    <operand>       <comment>
      
      All of the fields are optional, under appropriate circumstances.  An
      arbitrary amount of white space (space and tabs) can  separate  each
      field  (as  long as the maximum line length of 255 characters is not
      exceeded).  Each of fields are described below:
      
      
      Label Field. If the first character of the line is alphabetic, it is
      assumed  to  be  the  start  of  a label.  Subsequent characters are
      accepted as part of that  label  until  a  space,  tab,  or  ':'  is
      encountered.   The   assembler   assigns   a   value  to  the  label
      corresponding to the current  location  counter.  Labels  can  be  a
      maximum  of  13 characters long.  Labels can contain upper and lower
      case letters, digits, underscores,  and periods (the first character
      must  be alphabetic).  Labels are case sensitive - the label 'START'
      is a different label from 'start'.
      
      Operation  Field.  The  operation  field  contains  an   instruction
      (opcode)  mnemonic  which  specifies the action to be carried out by
      the  target  processor  when  this  instruction  is  executed.   The
      interpretation  of each mnemonic is dependent on the version of TASM
      being used (see  section  on  OPCODES  AND  ADDRESSING  MODES).  The
      operation  field  may  begin  in  any  column except the first.  The
      operation field is case insensitive.
      
      Operand Field. The operand field specifies the data to  be  operated
      on  by  the  instruction.  It may include expressions and/or special
      symbols describing the  addressing  mode  to  be  used.  The  actual
      format and interpretation is dependent on the target processor.  For
      a description of the format for currently supported processors,  see
      the section on OPCODES AND ADDRESSING MODES  for  the  processor  of
      interest.
      
      Comment  Field.  The  comment  field always begins with a semicolon.
      The rest of the line from the semicolon to the end of  the  line  is
      ignored  by  TASM,  but passed on to the listing file for annotation
      purposes.  The comment field must be the last field on a  line,  but
      it may be the only field, starting in column one, if desired.
      
      Multiple  Statement Lines. If the backslash character is encountered
      on a source line,  it is treated as a newline.  The remainder of the
      line  following  the  backslash  will be processed as an independent
      line of source code.  This allows one to put multiple statements  on
      a line.  This facility is not so useful of itself,  but when coupled
      with the capability  of  the  DEFINE  directive,  powerful  multiple
      statement  macros  can  be  constructed  (see  section  on ASSEMBLER
      DIRECTIVES).  Note that when  using  the  statement  separator,  the
      character  immediately  following  it should be considered the first
      character of a new line,  and thus must either be a start of a label

      TASM - Table Driven Assembler                                Page 8    
      
      or  white space (not an instruction).  As the examples show, a space
      is put between the backslash and the start of the next instruction.
      
      
      
      
      Some  examples  of  valid  source  statements follow (6502 mnemonics
      shown):
      
      label1  lda     byte1   ;get the first byte
              dec     byte1
              jne     label1
      
      ;
      label2
              sta     byte2,X
              ; a multiple statement line follows
              lda     byte1\ sta byte1+4\ lda byte2\ sta byte2+4
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      

      TASM - Table Driven Assembler                                Page 9    
      
      
      EXPRESSIONS
      
      Expressions are made  up  of  various  syntactic  elements  (tokens)
      combined  according  to  a set of syntactical rules.  The tokens are
      summarized as follows:
      
              1.  Labels
              2.  Constants
              3.  Location Counter Symbol
              4.  Operators
              5.  Parenthesis
      
      Labels. Labels are strings of characters that have a  numeric  value
      associated with them, generally representing an address.  Labels can
      contain  upper  and  lower case letters,  digits,  underscores,  and
      periods.  The first character must be a letter  (to  distinguish  it
      from a numeric constant).  The value of a label is limited to 16 bit
      precision.  Labels can contain up to 13 characters, all of which are
      significant (none are ignored when looking at a labels value,  as in
      some assemblers).
      
      Constants.  Numeric constants must always begin with a decimal digit
      (thus hexadecimal  constants  that  start  with  a  letter  must  be
      prefixed by a '0').  The radix is determined by a letter immediately
      following the digit string according to the following table:
      
              Radix           Suffix                  Prefix
              ---------------------------------------------------
              2               B or b                    %
              8               O or o                    @
              10              D or d (or nothing)
              16              H or h                    $
      
      Decimal is the default radix, so decimal constants need no suffix or
      prefix.
      
      The following representations are equivalent:
      
              1234H           or      $1234
              100d            or      100
              177400O         or      @177400
              01011000b       or      %01011000
      
      The  prefixes  are provided for compatibility with some other source
      code formats but introduce a problem of ambiguity.  Both '%' and '$'
      have alternate uses  ('%'  for  modulo,  '$'  for  location  counter
      symbol).  To  resolve this,  some simple rules are employed.  If the
      first character following a '%' is a '0' or '1', it is assumed to be
      a radix specifier and not the modulo  operator.  Similarly,  if  the
      first character following a '$' is a valid hexadecimal digit,  it is
      assumed to be a radix specifier and not the location  counter.  This
      can  cause problems,  however.  Suppose you wanted to find the value
      of the low byte of the label 'PNTR_TABLE', you might do this:
      
              (PNTR_TABLE%0100h)
      

      TASM - Table Driven Assembler                                Page 10  
      
      Here the '%' would mistakenly be taken for  a  radix  specifier.  To
      correct  the  problem one need only insert a space in an appropriate
      spot:
      
              (PNTR_TABLE % 0100h)
      
      Character  constants  are  single  characters  surrounded  by single
      quotes (following  quote  is  optional).  The  ASCII  value  of  the
      character  in the quotes is returned.  No escape provision exists to
      represent non-printable characters within the quotes,  but  this  is
      not  necessary  since  these  can  be  just as easily represented as
      numeric constants.
      
      String constants are one or more  characters  surrounded  by  double
      quotes.  Note  that string constants are not allowed in expressions.
      They are only allowable following the 'TITLE' and  'TEXT'  assembler
      directives.
      
      Location  Counter  Symbol. The current value of the location counter
      (PC) can be used in expressions by placing  a  '$'  in  the  desired
      place.  The  Location Counter Symbol is allowable anywhere a numeric
      constant is.  (Note that if the '$' is followed by a  decimal  digit
      then  it  is  taken to be the hexadecimal radix indicator instead of
      the Location Counter symbol,  as mentioned above).  The '*' may also
      be  used  to  represent the location counter,  but is less preferred
      because of its ambiguity with the multiplicative operator.
      
      Operators. Expressions can optionally contain operators  to  perform
      some   alterations   or  calculations  on  particular  values.   The
      operators are summarized as follows:
      
              Operator  Type          Description
              __________________________________________
              +        Additive       addition
              -                       subtraction
      
              *        Multiplicative multiplication
              /                       division
              %                       modulo
              <<                      logical shift left
              >>                      logical shift right
      
              ~        Unary          bit inversion (one's complement)
              -                       unary negation
      
              =        Relational     equal
              ==                      equal
              !=                      not equal
              <                       less than
              >                       greater than
              <=                      less than or equal
              >=                      greater than or equal
      
              &       Binary          binary 'and'
              |                       binary 'or'
              ^                       binary 'exclusive or'
      

      TASM - Table Driven Assembler                                Page 11  
      
      The syntax is much the same as in 'C' with the following notes:
      
              1.  No operator precedence is in effect.  Evaluation is from
                      left to right unless grouped by  parenthesis  (  see
                      example below).
      
              2.  All evaluations are done with 16 bit precision.
      
              3.  Both '=' and '==' are allowable equality checkers.  This
                      is allowed   since   the  syntax  does  not  provide
                      assignment capability (as '=' would normally be used
                      for).
      
      The relational operators return a value of 1 if the relation is true
      and 0 if it is false.  Sixteen bit signed arithmetic is used.
      
      It is always a good idea to explicitly indicate the desired order of
      evaluation with  parenthesis,  especially  to  maintain  portability
      since  TASM does not evaluate expressions in the same manner as many
      other assemblers.  To understand how it does arrive  at  the  values
      for expressions, consider the following example:
      
              1 + 2*3 + 4
      
      TASM would start at the left and read the first token '1'  and  then
      the  operator  '+'.  To  determine  what  to  add  to  the '1',  the
      expression evaluator would be called recursively on the remainder of
      the expression.  The next pass would read the '2' and '*'  and  then
      call  itself again to evaluate the rest.  Another level of recursion
      would take place in evaluating the '4'.  Since it is not followed by
      any more operators, the recursion would start undoing itself and the
      final expression would be evaluated as:
      
              1 + (2 * (3 + (4))) = 15
      
      If the user had desired the '*' to take precedence, the following
      could have been done:
      
              1 + (2*3) + 4
      
      Use parenthesis liberally.
      
      Here are some examples of valid expressions:
      
              (0f800H + tab)
              (label_2 >> 8)
              (label_3 << 8) & $f000
              $ + 4
              010010000100100b + 'a'
              (base + ((label_4 >> 5) & (mask << 2))
      
      
      
      
      
      
      

      TASM - Table Driven Assembler                                Page 12  
      
      
      ASSEMBLER DIRECTIVES
      
      Most of the assembler  directives  have  a  format  similar  to  the
      machine   instruction   format.   However,   instead  of  specifying
      operations for the processor to carry out,  the directives cause the
      assembler  to perform some function related to the assembly process.
      TASM has two types of assembler directives - those  that  mimic  the
      'C'  preprocessor  functions,  and  those  that  resemble  the  more
      traditional assembler directive functions.  Each of  these  will  be
      discussed.
      
      The  'C' preprocessor style directives are are invoked with a '#' as
      the  first  character  of  the  line  followed  by  the  appropriate
      directive  (just  as in 'C').  Thus,  these directives cannot have a
      label preceding  them (on the same line).  Note that in the examples
      directives are shown in upper case,  however,  either upper or lower
      case is acceptable.
      
      INCLUDE. The INCLUDE directive reads in and assembles the  indicated
      source  file.  INCLUDEs can be nested up to six levels.  This allows
      a convenient means to  keep  common  definitions,  declarations,  or
      subroutines  in  files  to  be included as needed.  The format is as
      follows:
      
              #INCLUDE        <filename>
      
      The  <filename>  must  be  enclosed in double quotes.  Here are some
      examples:
      
              #INCLUDE        "macros.h"
              #include "equates"
              #include "subs.asm"
      
      
      DEFINE.  The  DEFINE  directive  is  one of the most powerful of the
      directives and allows string substitution  with  optional  arguments
      (macros).  The format is as follows:
      
              #DEFINE  <macro_label>[(<arg_list>)]      [<macro_definition>]
      
              <macro_label> := character string to be expanded when found
                                      in the source file.
      
              <arg_list>    := optional argument list for variable
                                      substitution in macro expansion.
      
              <macro_def>   := character string to replace the occurrences
                                      of <macro_label> in the source file.
      
      
      
      The simplest form of the DEFINE directive might look like this:
      
              #DEFINE         MLABEL
      
      Notice  that no substitutionary string is specified.  The purpose of

      TASM - Table Driven Assembler                                Page 13  
      
      a statement like this would typically be to define a label  for  the
      purpose  of  controlling some subsequent conditional assembly (IFDEF
      or IFNDEF).
      
      A more complicated example,  performing simple  substitution,  might
      look like this:
      
              #DEFINE         VAR1_LO         (VAR1 & 255)
      
      This statement would cause all occurrences of the  string  'VAR1_LO'
      in the source to be substituted with '(VAR1 & 255)'.
      
      As  a  more  complicated  example,   using  the  argument  expansion
      capability, consider this:
      
              #DEFINE         ADD(xx,yy)      clc\ lda xx\ adc yy\ sta xx
      
      If the source file then contained a line like this:
      
              ADD(VARX,VARY)
      
      It would be expanded to:
      
              clc\ lda VARX\ adc VARY\ sta VARX
      
      The above example shows the use of the backslash ('\') character  as
      a  multiple  instruction  statement delimiter.  This approach allows
      the definition of fairly powerful,  multiple statement  macros.  The
      example shown generates 6502 instructions to add one memory location
      to another.
      
      Some rules associated with the argument list:
      
              1.  Use a maximum of 10 arguments.
      
              2.  An argument in the DEFINE statement  must  be  a  unique
                      string  (unique  on  that line) occurring only as an
                      argument  elsewhere  in  the  line.   TASM  does   a
                      straight  forward  search  for the occurrence of the
                      specified argument strings in  the  macro_definition
                      field  and  if  the  string  is  found somewhere not
                      intended,  bad things  will  happen.  In  the  above
                      example,  if  a  simple '(a,b)' had been used as the
                      argument list instead '(xx,yy)',  then each  'a'  in
                      the  definition  would be expanded (e.g.  the 'a' in
                      'lda').
      
              3.  Each argument should be a maximum of 15 characters.
      
      Note that macros can be defined on the TASM command line, also, with
      the '-d' option flag.
      
      IFDEF.  This directive can be used to optionally assemble a block of
      code.  It has the following form:
      
              #IFDEF  <macro_label>
      

      TASM - Table Driven Assembler                                Page 14  
      
      When invoked,  the list of  macro  labels  (established  via  DEFINE
      directives) is searched.  If the label is found, the following lines
      of  code  are  assembled.  If  not found,  the input file is skipped
      until an ENDIF or ELSE directive is found.
      
      Lines that are skipped over still appear in the listing file,  but a
      '~'  will appear immediately after the current PC and no object code
      will be generated (this is applicable to IFDEF, IFNDEF, and IF).
      
      IFNDEF. This directive is the opposite of the IFDEF  directive.  The
      block   of  code  following  is  assembled  only  if  the  specified
      macro_label is undefined.  It has the following form:
      
              #IFNDEF  <macro_label>
      
      When invoked,  the list of  macro  labels  (established  via  DEFINE
      directives)  is searched.  If the label is not found,  the following
      lines of code are assembled.  If it is  found,  the  input  file  is
      skipped until an ENDIF or ELSE directive is found.
      
      IF.  This  directive  can  be used to optionally assemble a block of
      code dependent on the value of a given expression.  The format is as
      follows:
      
              #IF     <expr>
      
      If the expression <expr> evaluates to non-zero, the following block
      of code is assembled (until an ENDIF or ELSE is encountered).
      
      
      ENDIF. This directive must always follow an  IFDEF,  IFNDEF,  or  IF
      directive and signifies the end of the conditional block.
      
      ELSE. This directive can optionally be used with IFDEF,  IFNDEF  and
      IF  to  delineate  an alternate block of code to be assembled if the
      block  immediately  following  the  IFDEF,   IFNDEF  or  IF  is  not
      assembled.
      
      Here are some examples of the use of IFDEF, IFNDEF,  IF,  ELSE,  and
      ENDIF:
      
              #IFDEF  label1
              lda     byte1
              sta     byte2
              #ENDIF
      
              #ifdef  label1
              lda     byte1
              #else
              lda     byte2
              #endif
      
              #ifndef label1
              lda     byte2
              #else
              lda     byte1
              #endif

      TASM - Table Driven Assembler                                Page 15  
      
      
              #if ($ >= 1000h)
              ; generate an invalid statement to cause an error
              ;  when we go over the 4K boundary.
               !!! PROM bounds exceeded.
              #endif
      
      ORG. This directive  provides  the  means  to  set  the  Instruction
      Pointer  (a.k.a.  Program Counter) to the desired value.  The format
      is:
      
              [<label>] .ORG    <expr>
      
      The <label> is optional.  The Instruction pointer  is  assigned  the
      value  of  the  expression,  <expr>.  For example,  to generate code
      starting at address 1000H, the following could be done:
      
              start   .ORG    1000H
      
      The expression  (<expr>)  may  contain  references  to  the  current
      Instruction Pointer, thus allowing various manipulations to be done.
      For  example,  to align the Instruction Pointer on the next 256 byte
      boundary, the following could be done:
      
                      .ORG  (($ + FFH) & FF00H)
      
      ORG can also be used to reserve space without assigning values:
      
                      .ORG    $+8
      
      An alternate form of ORG is '*=' or '$='.  Thus  the  following  two
      examples as exactly equivalent to the previous example:
      
                      *=*+8
                      $=$+8
      
      EQU. This directive can be used to  assign  values  to  labels.  The
      labels  can  then  be  used  in  expressions in place of the literal
      constant.  The format is:
      
              <label> .EQU  <expr>
      
      Here is an example:
      
              MASK    .EQU    F0H
              ;
                      lda     IN_BYTE
                      and     MASK
                      sta     OUT_BYTE
      
      An  alternate  form  of  'EQU'  is  '='.  The  previous  example  is
      equivalent to:
      
              MASK    =       F0H
      or
              MASK    =FOH
              MASK    =$FO

      TASM - Table Driven Assembler                                Page 16  
      
      
      White  space must exist after the label,  but none is required after
      the '='.
      
      
      BYTE.  This directive allows a value assignment to the byte pointed
      to by the current Instruction Pointer.  The format is:
      
              [<label>] .BYTE   <expr>
      
      Only the lower eight bits of <expr> are used.  Only one byte at a
      time may be assigned.  Here are some examples:
      
              label1  .BYTE   10010110B
                      .byte   'a'
                      .byte   0
      
      
      WORD. This directive allows a value assignment to the next two bytes
      pointed to by the current Instruction Pointer.  The format is:
      
              [<label>] .WORD  <expr>
      
      The  least  significant  byte  of  <expr>  is  put  at  the  current
      Instruction  Pointer  with  the  most  significant  byte at the next
      sequential location.  Here are some examples:
      
              data_table      .WORD   (data_table + 1)
                              .word   $1234
                              .Word   (('x' - 'a')  << 2)
      
      
      TEXT.  This  directive  allows  an ASCII string to be used to assign
      values  to  a  sequence  of  locations  starting  at   the   current
      Instruction Pointer.  The format is:
      
              [<label>] .TEXT   "<string>"
      
      The  ASCII value of each character in <string> is taken and assigned
      to the next sequential location.  Here are some examples:
      
              message1  .TEXT  "Disk I/O error"
              message2  .text  "Enter file name "
                        .text  "abcdefg"
      
      TASM  only  shows  the first four bytes of the string in the listing
      file, but all bytes are included in the object file.
      
      BLOCK. This directive causes the Instruction Pointer to advance  the
      specified  number  of  bytes without assigning values to the skipped
      over locations.  The format is:
      
              [<label>] .BLOCK        <expr>
      
      Some valid examples are:
      
              word1   .BLOCK  2

      TASM - Table Driven Assembler                                Page 17  
      
              byte1   .block  1
              buffer  .block  80
      
      TITLE. This directive allows the user to define a title string  that
      appears  at the top of each page of the list file (assuming the PAGE
      mode is on).  The format is:
      
                      .TITLE  "<string>"
      
      The string should not exceed 80 characters.  Here are some examples:
      
                      .TITLE  "Controller version 1.1"
                      .title  "This is the title of the assembly"
                      .title  ""
      
      
      LIST/NOLIST.  These directives can be used to alternately turn the
      output to the list file on (LIST) or off (NOLIST).  The format is:
      
              .LIST
              .NOLIST
      
      
      PAGE/NOPAGE. These directives can be used to  alternately  turn  the
      paging mode on (PAGE) or off (NOPAGE).  If paging is in effect, then
      every  sixty  lines  of  output  will  be  followed by a Top of Form
      character and a two line header containing  page  number,  filename,
      and the title.  The format is:
      
              .PAGE
              .NOPAGE
      
      
      
      EJECT.  This  directive  can  be used to force a Top of Form and the
      generation of a page header on the list file.  It has no  effect  if
      the paging mode is off (see PAGE/NOPAGE).  The format is:
      
              .EJECT
      
      ADDINSTR.  This  directive  can  be  used   to   define   additional
      instructions for TASM to use in this assembly.  The format is:
      
      [<label>]   .ADDINSTR   <inst> <args> <opcode> <nbytes> <modop> <class>
      
      The fields are separated by white space just as they would appear in an
      instruction definition file as described in TASM INSTRUCTION SET
      TABLE DEFINITION.
      
      END.   This   directive   should  follow  all  code/data  generating
      statements in the source file.  It forces  the  last  record  to  be
      written to the object file.  The format is:
      
              [<label>]       .END
      
      
      

      TASM - Table Driven Assembler                                Page 18  
      
      
      OBJECT FILE FORMATS
      
      TASM supports three object file formats:
      
              1.  Intel Hex (default).
              2.  MOS Technology Hex.
              3.  Binary
      
      Each are described below:
      
      
      
      Intel Hex Object Format. This is the default format.  This format is
      line  oriented  and  uses only printable ASCII characters except for
      the carriage return/line feed at the end of each line.  Each line in
      the file assumes the following format:
      
      :NNAAAARRHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHCCTT
      
      Where:
      
      All fields marked 'hex' consist of two  or  four  ASCII  hexadecimal
      digits  (0-9,  A-F).  A maximum of 24 data bytes will be represented
      on each line.
      
      :       = Record Start Character
      NN      = Byte Count (hex)
      AAAA    = Address of first byte (hex)
      RR      = Record Type (hex, 00 except for last record which is 01)
      HH      = Data Bytes (hex)
      CC      = Check Sum (hex)
      TT      = Line Terminator (carriage return, line feed)
      
      The last line of the file will be a record conforming to  the  above
      format with a byte count of zero (':00000001FF').
      
      The checksum is defined as:
      
              sum      =  byte_count + address_hi + address_lo +
                              record_type + (sum of all data bytes)
              checksum =  ((-sum) & ffh)
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      

      TASM - Table Driven Assembler                                Page 19  
      
      
      MOS  Technology  Hex Object Format. This format is line oriented and
      uses  only  printable  ASCII  characters  except  for  the  carriage
      return/line  feed  at  the  end of each line.  Each line in the file
      assumes the following format:
      
      ;NNAAAAHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHCCCCTT
      
      Where:
      
      All fields marked 'hex' consist of two  or  four  ASCII  hexadecimal
      digits  (0-9,  A-F).  A maximum of 24 data bytes will be represented
      on each line.
      
      ;       = Record Start Character
      NN      = Byte Count (hex)
      AAAA    = Address of first byte (hex)
      HH      = Data Bytes (hex)
      CCCC    = Check Sum (hex)
      TT      = Line Terminator (carriage return, line feed)
      
      The last line of the file will be a record with a byte count of zero
      (';00').
      
      The checksum is defined as:
      
              sum      =  byte_count + address_hi + address_lo +
                              record_type + (sum of all data bytes)
              checksum =  (sum & ffffh)
      
      
      
      
      
      Binary   Object   Format.   This  file  format  has  only  a  binary
      representation of each data byte with no address, checksum or format
      description,  whatsoever.  It is often a convenient format to use to
      pass  the  data to other programs on your PC (like a PROM programmer
      package) but because of the  nonprintability  and  lack  of  address
      information,  it  is  not  often  used to transmit the code to other
      systems.
      
      Note that when this object format is selected (-b  option),  the  -c 
      option  is  forced.  This  is  done so that no ambiguity arises as a 
      result of the lack of address information in the file.  Without  the 
      -c  option,   discontinuous  blocks  of  object  code  would  appear 
      contiguous.  
      
      
      
      
      
      
      
      
      
      

      TASM - Table Driven Assembler                                Page 20  
      
      
      LISTING FILE FORMAT
      
      Each line of source code generates one (or more) lines of output  in
      the listing file.  The fields of the output line are as follows:
      
              1.  Current  source  file  line  number  (4 decimal digits).
      
              2.  An optional '+' appears if this is  an  'INCLUDE'  file.
                      (One '+' for each level of INCLUDE invoked).
      
              3.  Current Instruction Pointer (4 hex digits).  An optional
                      '~' follows the Instruction Pointer if the  line  of
                      source  code  is  not  being assembled because of an
                      IFDEF, IFNDEF, or IF directive.
      
              4.  Resulting code/data generated from this source line (two
                      hex digits per byte, each byte separated by a space,
                      up to four bytes per line).
      
              5.  The  source  line  exactly  as  it appears in the source
                      file.
      
      If  paging  is  enabled (by either the '-p' option flag or the .PAGE
      directive) some additional fields will be inserted into the  listing
      file every 60 lines.  These fields are:
      
              1.  Top of Form (form feed).
              2.  Assembler identifier (e.g. "TASM 6502 Assembler").
              3.  Initial source file name.
              4.  Page number.
              5.  Title.
      
      For an example of the listing file format, see appendix A.
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      

      TASM - Table Driven Assembler                                Page 21  
      
      
      PROM PROGRAMMING
      
      A wide variety of PROM programming equipment is available  that  can
      use  object  code  in  one or more of the formats TASM supports.  We
      will not try to list all such  compatible  systems  here,  but  will
      mention one configuration that has worked well for us.
      
      We have used the Apparat "IBM PROM Blaster,  24 Pin" (available from
      Apparat Inc.,  4401 Tamarac Parkway,  Denver,  Colorado 80237, $129)
      for programming 24  pin  EPROMs  with  much  success.  The  software
      supplied  with  this  product  will accept a TASM object file in the
      binary  format  (-b  option  flag  on  TASM   command   line).   The
      combination   of  TASM  and  the  PROM  Blaster  make  for  a  truly
      inexpensive solution to the problem of generating  PROMed  code  for
      target microprocessor systems.  (STI is not affiliated or associated
      with Apparat in any way).
      
      
      
      Some additional notes about generating code to be put in PROMs:
      
              1.  It  is  often  desirable  to  have all bytes in the PROM
                      programmed even if not explicitly assigned  a  value
                      in the source code (e.g.  the bytes are skipped over
                      with a .ORG statement).  This can be accomplished by
                      using the -c (contiguous block) and  the  -f  (fill)
                      command  line option flags.  The -c will ensure that
                      every byte from the lowest byte assigned a value  to
                      the the highest byte assigned a value will be in the
                      object  file  with no gaps.  The -f flag will assign
                      the specified value to all bytes before the assembly
                      begins so that when the object file is written,  all
                      bytes  not  assigned a value in the source code will
                      have a known value.  As an  example,  the  following
                      command  line  will  generate  object  code  in  the
                      default Intel Hex format with all bytes not assigned
                      a value in the source set to EA (hex, 6502 NOP):
      
                      tasm -65 -c -fEA test.asm
      
              2.  To ensure that TASM generates object code to  cover  the
                      full  address  range of the target PROM,  put a .ORG
                      statement at the end of the source file set  to  the
                      last address desired.  For example, to generate code
                      to  be  put  in  a  2716  EPROM  (2 Kbytes) from hex
                      address $1000 to $17ff,  do something like  this  in
                      the source file:
      
                               ;start of the file
                               .ORG    $1000
                               ;rest of the source code follows
       
                               <source code>
       
                               ;end of the source code
                               .ORG    $17ff

      TASM - Table Driven Assembler                                Page 22  
      
                               .BYTE   0
                               .END
      
                      Now,  to  invoke  TASM  to  generate the code in the
                      binary format with all unassigned bytes  set  to  00
                      (6502 BRK), do the following:
      
                      tasm -65 -b -f00 test.asm
      
                      Note that -b forces the -c option.
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      

      TASM - Table Driven Assembler                                Page 23  
      
      
      ERROR MESSAGES
      
      
      Error Message                           Description
      --------------------------------------------------------
      unrecognized directive..................A statement starting  with a
                                              '.'  or  '#'  has a mnemonic
                                              that is  not  defined  as  a
                                              directive.
      
      unrecognized  instruction...............A  statement  has  an opcode
                                              mnemonic   that    is    not
                                              defined.
      
      unrecognized argument...................A statement has  an  operand
                                              format that is not defined.
      
      label value misaligned..................The value of a label appears
                                              to have a different value on
                                              the  second pass then it was
                                              computed  to  have  on   the
                                              first    pass.    This    is
                                              generally due to  Zero  Page
                                              Addressing   mode   problems
                                              with  the  6502  version  of
                                              TASM.  Labels  that are used
                                              in operands  for  statements
                                              that   could  utilized  Zero
                                              Page addressing mode  should
                                              always   be  defined  before
                                              used as an operand.
      
      label table overflow....................To  many  labels  have  been
                                              encountered.
      
      No END directive before EOF.............The source file did not have
                                              an   END  directive  in  it.
                                              This is not fatal,  but  may
                                              cause  the  last object file
                                              record to be lost.
      
      No  files  specified....................TASM  was  invoked  with  no
                                              source file specified.
      
      Unknown  option  flag...................TASM  was  invoked  with  an
                                              undefined option flag on the
                                              command line.
      
      Source file open error..................TASM was not  able  to  open
                                              the specified source file.
      
      List file open error....................TASM was not  able  to  open
                                              the specified list file.
      
      Object file open error..................TASM was not  able  to  open
                                              the specified object file.

      TASM - Table Driven Assembler                                Page 24  
      
      
      Unknown token...........................Unexpected  characters  were
                                              encountered while parsing an
                                              expression.
      
      maximum number of macros exceeded.......To  many  macros   (DEFINEs)
                                              have been encountered.
      
      macro buffer overflow...................The buffer from which  space
                                              is   allocated   for   macro
                                              definitions is exhausted.
      
      range of relative branch exceeded.......A branch instruction exceeds
                                              the  maximum   range   (6502
                                              Version).
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      

      TASM - Table Driven Assembler                                Page 25  
      
      
      BUGS AND LIMITATIONS
      
      Limitations and Specifications
      ----------------------------------------------------------------
      Maximum number of labels                2000
      Maximum length of labels                13 characters
      Maximum address space                   64 Kbytes (65536 bytes)
      Maximum number of nested INCLUDES       6
      Maximum length of TITLE string          79 characters
      Maximum Source line length              255 characters
      Maximum length of expressions           255 characters
      Maximum length of pathnames             79 characters
      Maximum length of command line          127 characters
      
      Maximum number of macros                1000
      Maximum number of macro arguments       10
      Maximum length of macro argument        16 characters
      Heap size (for labels and macros)       20000 bytes
      
      Memory requirements                     160K (32K for code, 64K for
                                              data and stack, 64K for
                                              opcode memory image*).
      
      
      *Note that TASM uses the 64 Kbyte segment immediately following  the
      data/stack  segment to store assembled opcodes and data before being
      written to the object file.
      
      
      Bugs
      
      1.  The 8048 version of TASM does not check for use of memory beyond
              any  reasonable  bounds (e.g.  an 8048 has a maximum address
              space of 4 Kbytes but TASM will let  you  pretend  that  you
              have 64 Kbytes).
      
      2.  Expression evaluation has no operator precedence in effect which
              can  make  for  unexpected results if not explicitly grouped
              with parenthesis.
      
      3.  First  page  of  listing file will not show a user defined title
              (defined via TITLE directive).
      
      4.  TASM sometimes does not generate error messages  for  improperly
              formed expressions.
      
      5.  TASM expands macros in comments at the end of a line (but not in
              lines that are all comment).
      
      6.  TASM does not generate an error message when a EQU directive has
              an undefined label on the right hand side.
      
      
      
      
      

      TASM - Table Driven Assembler                                Page 26  
      
      
      6502 INSTRUCTIONS AND ADDRESSING MODES
      
      The acceptable 6502 opcode mnemonics for TASM are as follows:
      
               ADC  AND  ASL  BCC  BCS  BEQ  BNE  BMI  BPL  BVC  BVS  BIT
               BRK  CLC  CLD  CLI  CLV  CMP  CPX  CPY  DEC  DEX  DEY  EOR
               INC  INX  INY  JMP  JSR  LDA  LDX  LDY  LSR  NOP  ORA  PHA
               PHP  PLA  PLP  ROL  ROR  RTI  RTS  SBC  SEC  SED  SEI  STA
               STX  STY  TAX  TAY  TSX  TXA  TXS  TYA
      
      TASM  also  supports the following instructions that are part of the
      Rockwell  R65C02  and  R65C00/21  microprocessor  instruction  sets.
      Those  that  are  marked  as  set A are applicable to the R65C02 and
      those marked as set B are  applicable  to  the  R65C00/21  (A+B  for
      both):
      
              Mnemonic        Description                Address Mode  Set
              ---------------------------------------------------------------
              ADC             Add with carry             (IND)         A
              AND             And memory with A          (IND)         A
              BIT             Test memory bits with A    ABS,X         A
              BIT             Test memory bits with A    ZP,X          A
              BIT             Test memory bits with A    IMM           A
              CMP             Compare memory with A      (IND)         A
              DEC             Decrement A                A             A
              EOR             Exclusive OR memory with A (IND)         A
              INC             Increment A                A             A
              JMP             Jump                       (ABS,X)       A
              LDA             Load A with memory         (IND)         A
              ORA             OR A with memory           (IND)         A
              SBC             Subtract memory form A     (IND)         A
              STA             Store A in memory          (IND)         A
              STZ             Store zero                 ABS           A
              STZ             Store zero                 ABS,X         A
              STZ             Store zero                 ZP            A
              STZ             Store zero                 ZP,X          A
              TRB             Test and reset memory bit  ABS           A
              TRB             Test and reset memory bit  ZP            A
              TSB             Test and set memory bit    ABS           A
              TSB             Test and set memory bit    ZP            A
      
              BRA             Branch Always              REL           A+B
      
              BBR0            Branch on Bit 0 Reset      ZP,REL        A+B
              BBR1            Branch on Bit 1 Reset      ZP,REL        A+B
              BBR2            Branch on Bit 2 Reset      ZP,REL        A+B
              BBR3            Branch on Bit 3 Reset      ZP,REL        A+B
              BBR4            Branch on Bit 4 Reset      ZP,REL        A+B
              BBR5            Branch on Bit 5 Reset      ZP,REL        A+B
              BBR6            Branch on Bit 6 Reset      ZP,REL        A+B
              BBR7            Branch on Bit 7 Reset      ZP,REL        A+B
      
              BBS0            Branch on Bit 0 Set        ZP,REL        A+B
              BBS1            Branch on Bit 1 Set        ZP,REL        A+B
              BBS2            Branch on Bit 2 Set        ZP,REL        A+B
              BBS3            Branch on Bit 3 Set        ZP,REL        A+B

      TASM - Table Driven Assembler                                Page 27  
      
              BBS4            Branch on Bit 4 Set        ZP,REL        A+B
              BBS5            Branch on Bit 5 Set        ZP,REL        A+B
              BBS6            Branch on Bit 6 Set        ZP,REL        A+B
              BBS7            Branch on Bit 7 Set        ZP,REL        A+B
      
              MUL             Multiply                   Implied       B
      
              PHX             Push Index X               Implied       A+B
              PHY             Push Index Y               Implied       A+B
              PLX             Pull Index X               Implied       A+B
              PLY             Pull Index Y               Implied       A+B
      
              RMB0            Reset Memory Bit 0         ZP            A+B
              RMB1            Reset Memory Bit 1         ZP            A+B
              RMB2            Reset Memory Bit 2         ZP            A+B
              RMB3            Reset Memory Bit 3         ZP            A+B
              RMB4            Reset Memory Bit 4         ZP            A+B
              RMB5            Reset Memory Bit 5         ZP            A+B
              RMB6            Reset Memory Bit 6         ZP            A+B
              RMB7            Reset Memory Bit 7         ZP            A+B
      
              SMB0            Set   Memory Bit 0         ZP            A+B
              SMB1            Set   Memory Bit 1         ZP            A+B
              SMB2            Set   Memory Bit 2         ZP            A+B
              SMB3            Set   Memory Bit 3         ZP            A+B
              SMB4            Set   Memory Bit 4         ZP            A+B
              SMB5            Set   Memory Bit 5         ZP            A+B
              SMB6            Set   Memory Bit 6         ZP            A+B
              SMB7            Set   Memory Bit 7         ZP            A+B
      
      Note that correct assembly of these extended  instructions  has  not
      been tested on a target system.
      
      Addressing  modes  are denoted as follows:
      
              ABS               Absolute
              ZP                Zero Page
              ABS,X             Absolute X
              ZP,X              Zero Page X
              ABS,Y             Absolute Y
              ZP,Y              Zero Page Y
              A                 Accumulator
              (IND,X)           Indirect X
              (IND),Y           Indirect Y
              (IND)             Indirect
              #IMM              Immediate
              REL               Relative (Branch instructions only)
              ZP,REL            Zero Page, Relative
              Implied           Implied
      
      Note  that Zero Page addressing can not be explicitly requested.  It
      is used if the value of the operand is  representable  in  a  single
      byte for the applicable statements.
      
      The '-x' command line option can be  used  to  enable  the  extended
      instructions.  A  '-x'  with  no  digit  following  will  enable the
      standard set plus both extended sets.  The 6502 version of TASM uses

      TASM - Table Driven Assembler                                Page 28  
      
      three bits in the instruction class  mask  to  determine  whether  a
      given  instruction  is enabled or not.  Bit 0 enables the basic set,
      bit 1 enables set A (R65C02) and bit 2 enables  set  B  (R65C00/21).
      The following table shows various options:
      
              Class Mask        Enabled Instructions
                              BASIC   R65C02  R65C00/21
              --------------------------------------------
              1               yes     no      no
              2               no      yes     no
              3               yes     yes     no
              4               no      no      yes
              5               yes     no      yes
              6               no      yes     yes
              7               yes     yes     yes
      
      Thus,  to enable the basic set plus the R65C02 instructions,  invoke
      the '-x3' command line option.
      
      See manufacturer's data for  a  more  complete  description  of  the
      meaning of the mnemonics and addressing modes.
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      

      TASM - Table Driven Assembler                                Page 29  
      
      
      8048 INSTRUCTIONS AND ADDRESSING MODES
      
      The following list shows the acceptable opcode mnemonics  and  their
      corresponding  operand  formats for the 8048 version of TASM.  Where
      'Rn' is seen,  R0 through R7  may  be  substituted.  Other  symbolic
      fields are as follows:
      
              SYMBOLIC            DESCRIPTION
              -----------------------------------------------
              <addr8>             Absolute address (8 bits)
              <addr11>            Absolute address (11 bits)
              <immed>             Immediate data
      
      Any valid TASM expression can appear in the  place  of  any  of  the
      above symbolics.
      
      The lines that are marked with an (8041),  (8022),  or (8021) on the
      far  right are extended instructions that are available only if a -x
      option has  been  invoked  on  the  command  line.  The  classes  of
      instructions  (and their bit assignment in the class mask) are shown
      below:
      
              BIT     PROCESSOR
              -------------------------------
              0       8X48, 8035, 8039, 8049
              1       8X41A
              2       8022
              3       8021
      
      Thus, to enable the basic 8048 set plus the 8022 set, a -x5 could be
      used on the command line.
      
      Note that some of the base instructions should be disabled  for  the
      8041, 8022, and 8021, but are not.
      
      OPCODE  OPERANDS        DESCRIPTION
      -------------------------------------------------------------------
      ADD     A,Rn            Add Register to Acc
      ADD     A,@R0           Add Indirect RAM to Acc
      ADD     A,@R1           Add Indirect RAM to Acc
      ADD     A,#<immed>      Add Immediate data to Acc
      
      ADDC    A,Rn            Add Register to Acc with carry
      ADDC    A,@R0           Add Indirect RAM to Acc with carry
      ADDC    A,@R1           Add Indirect RAM to Acc with carry
      ADDC    A,#<immed>      Add Immediate data to Acc with carry
      
      ANL     A,Rn            AND Register to Acc
      ANL     A,@R0           AND Indirect RAM to Acc
      ANL     A,@R1           AND Indirect RAM to Acc
      ANL     A,#<immed>      AND Immediate data to Acc
      ANL     BUS,#<immed>    AND Immediate data to BUS
      ANL     P1,#<immed>     AND Immediate data to port P1
      ANL     P2,#<immed>     AND Immediate data to port P2
      
      ANLD    P4,A            AND Acc to Expander port P4

      TASM - Table Driven Assembler                                Page 30  
      
      ANLD    P5,A            AND Acc to Expander port P5
      ANLD    P6,A            AND Acc to Expander port P6
      ANLD    P7,A            AND Acc to Expander port P7
      
      CALL    <addr11>        Call subroutine
      
      CLR     A               Clear Acc
      CLR     C               Clear Carry
      CLR     F0              Clear Flag 0
      CLR     F1              Clear Flag 1
      
      CPL     A               Complement Acc
      CPL     C               Complement Carry
      CPL     F0              Complement Flag F0
      CPL     F1              Complement Flag F1
      
      DA      A               Decimal adjust Acc
      
      DEC     A               Decrement Acc
      DEC     Rn              Decrement Register
      
      DIS     I               Disable Interrupts
      DIS     TCNTI           Disable Timer/Counter Interrupt
      
      DJNZ    Rn,<addr8>      Decrement Register and Jump if nonzero
      
      EN      DMA             Enable DMA                           (8041)
      EN      FLAGS           Enable Flags                         (8041)
      EN      I               Enable External Interrupt
      EN      TCNTI           Enable Timer/Counter Interrupt
      ENT0    CLK             Enable Clock Output
      
      IN      A,DBB           Input Data Bus to Acc                (8041)
      IN      A,P0            Input Port 0 to Acc                  (8021)
      IN      A,P1            Input Port 1 to Acc
      IN      A,P2            Input Port 2 to Acc
      
      INC     A               Increment Acc
      INC     Rn              Increment Register
      INC     @R0             Increment Indirect RAM
      INC     @R1             Increment Indirect RAM
      
      INS     A,BUS           Strobed Input of Bus to Acc
      
      JB0     <addr8>         Jump if Acc bit 0 is set
      JB1     <addr8>         Jump if Acc bit 1 is set
      JB2     <addr8>         Jump if Acc bit 2 is set
      JB3     <addr8>         Jump if Acc bit 3 is set
      JB4     <addr8>         Jump if Acc bit 4 is set
      JB5     <addr8>         Jump if Acc bit 5 is set
      JB6     <addr8>         Jump if Acc bit 6 is set
      JB7     <addr8>         Jump if Acc bit 7 is set
      JMP     <addr11>        Jump
      JC      <addr8>         Jump if Carry is set
      JF0     <addr8>         Jump if Flag F0 is set
      JF1     <addr8>         Jump if Flag F1 is set
      JNC     <addr8>         Jump if Carry is clear

      TASM - Table Driven Assembler                                Page 31  
      
      JNI     <addr8>         Jump if Interrupt input is clear
      JNIBF   <addr8>         Jump if IBF is clear                 (8041)
      JNT0    <addr8>         Jump if T0 is clear
      JNT1    <addr8>         Jump if T1 is clear
      JNZ     <addr8>         Jump if Acc is not zero
      JOBF    <addr8>         Jump if OBF is set                   (8041)
      JTF     <addr8>         Jump if Timer Flag is set
      JT0     <addr8>         Jump if T0 pin is high
      JT1     <addr8>         Jump if T1 pin is high
      JZ      <addr8>         Jump if Acc is zero
      JMPP    @A              Jump Indirect (current page)
      
      MOV     A,PSW           Move PSW to Acc
      MOV     A,Rn            Move Register to Acc
      MOV     A,T             Move Timer/Counter to Acc
      MOV     A,@R0           Move Indirect RAM to Acc
      MOV     A,@R1           Move Indirect RAM to Acc
      MOV     A,#<immed>      Move Immediate data to Acc
      MOV     PSW,A           Move Acc to PSW
      MOV     Rn,A            Move Acc to Register
      MOV     Rn,#<immed>     Move Immediate data to Register
      MOV     STS,A           Move Acc to STS                      (8041)
      MOV     T,A             Move Acc to Timer/Counter
      MOV     @R0,A           Move Acc to Indirect RAM
      MOV     @R1,A           Move Acc to Indirect RAM
      MOV     @R0,#<immed>    Move Immediate data to Indirect RAM
      MOV     @R1,#<immed>    Move Immediate data to Indirect RAM
      
      MOVD    A,P4            Move half-byte Port 4 to Acc (lower nibble)
      MOVD    A,P5            Move half-byte Port 5 to Acc (lower nibble)
      MOVD    A,P6            Move half-byte Port 6 to Acc (lower nibble)
      MOVD    A,P7            Move half-byte Port 7 to Acc (lower nibble)
      MOVD    P4,A            Move lower nibble of Acc to Port 4
      MOVD    P5,A            Move lower nibble of Acc to Port 5
      MOVD    P6,A            Move lower nibble of Acc to Port 6
      MOVD    P7,A            Move lower nibble of Acc to Port 7
      
      MOVP    A,@A            Move Indirect Program data to Acc
      MOVP3   A,@A            Move Indirect Program data to Acc (page 3)
      
      MOVX    A,@R0           Move Indirect External RAM to Acc
      MOVX    A,@R1           Move Indirect External RAM to Acc
      MOVX    @R0,A           Move Acc to Indirect External RAM
      MOVX    @R1,A           Move Acc to Indirect External RAM
      
      NOP                     No operation
      
      ORL     A,Rn            OR Register to Acc
      ORL     A,@R0           OR Indirect RAM to Acc
      ORL     A,@R1           OR Indirect RAM to Acc
      ORL     A,#<immed>      OR Immediate data to Acc
      ORL     BUS,#<immed>    OR Immediate data to BUS
      ORL     P1,#<immed>     OR Immediate data to port P1
      ORL     P2,#<immed>     OR Immediate data to port P2
      
      ORLD    P4,A            OR lower nibble of Acc with P4
      ORLD    P5,A            OR lower nibble of Acc with P5

      TASM - Table Driven Assembler                                Page 32  
      
      ORLD    P6,A            OR lower nibble of Acc with P6
      ORLD    P7,A            OR lower nibble of Acc with P7
      
      OUTL    BUS,A           Output Acc to Bus
      OUT     DBB,A           Output Acc to DBB                    (8041)
      OUTL    P0,A            Output Acc to Port P0                (8021)
      OUTL    P1,A            Output Acc to Port P1
      OUTL    P2,A            Output Acc to Port P2
      
      RAD                     Move A/D Converter to Acc            (8022)
      
      RET                     Return from subroutine
      RETI                    Return from Interrupt w/o PSW restore(8022)
      RETR                    Return from Interrupt w/  PSW restore
      
      RL      A               Rotate Acc Left
      RLC     A               Rotate Acc Left through Carry
      RR      A               Rotate Acc Right
      RRC     A               Rotate Acc Right through Carry
      
      SEL     AN0             Select Analog Input 0                (8022)
      SEL     AN1             Select Analog Input 1                (8022)
      SEL     MB0             Select Memory Bank 0
      SEL     MB1             Select Memory Bank 1
      SEL     RB0             Select Register Bank 0
      SEL     RB1             Select Register Bank 1
      
      STOP    TCNT            Stop Timer/Counter
      STRT    CNT             Start Counter
      STRT    T               Start Timer
      
      SWAP    A               Swap nibbles of Acc
      
      XCH     A,Rn            Exchange Register with Acc
      XCH     A,@R0           Exchange Indirect RAM with Acc
      XCH     A,@R1           Exchange Indirect RAM with Acc
      
      XCHD    A,@R0           Exchange lower nibble of Indirect RAM w/ Acc
      XCHD    A,@R1           Exchange lower nibble of Indirect RAM w/ Acc
      
      XRL     A,Rn            Exclusive OR Register to Acc
      XRL     A,@R0           Exclusive OR Indirect RAM to Acc
      XRL     A,@R1           Exclusive OR Indirect RAM to Acc
      XRL     A,#<immed>      Exclusive OR Immediate data to Acc
      
      
      See manufacturer's data for  a  more  complete  description  of  the
      meaning of the mnemonics and addressing modes.
      
      
      
      
      
      
      
      
      

      TASM - Table Driven Assembler                                Page 33  
      
      
      8051 INSTRUCTIONS AND ADDRESSING MODES
      
      The following list shows the acceptable opcode mnemonics  and  their
      corresponding  operand  formats for the 8051 version of TASM.  Where
      'Rn' is seen,  R0 through R7  may  be  substituted.  Other  symbolic
      fields are as follows:
      
              SYMBOLIC            DESCRIPTION
              -----------------------------------------------
              <addr11>            Absolute address (11 bits)
              <addr16>            Absolute address (16 bits)
              <bit>               Bit address
              <immed>             Immediate data
              <direct>            Direct RAM address
              <rel>               Relative address
      
      Any valid TASM expression can appear in the  place  of  any  of  the
      above symbolics.
      
      OPCODE  OPERAND             DESCRIPTION
      --------------------------------------------------------------------
      ACALL   <addr11>            Absolute Call
      
      ADD     A,Rn                Add Register to Acc
      ADD     A,@R0               Add Indirect RAM to Acc
      ADD     A,@R1               Add Indirect RAM to Acc
      ADD     A,#<immed>          Add Immediate data to Acc
      ADD     A,<direct>          Add Direct RAM to Acc
      
      ADDC    A,Rn                Add Register to Acc with carry
      ADDC    A,@R0               Add Indirect RAM to Acc with carry
      ADDC    A,@R1               Add Indirect RAM to Acc with carry
      ADDC    A,#<immed>          Add Immediate data to Acc with carry
      ADDC    A,<direct>          Add Direct RAM to Acc with carry
      
      AJMP    <addr11>            Absolute Jump
      
      ANL     A,Rn                AND Register and Acc
      ANL     A,@R0               AND Indirect RAM and Acc
      ANL     A,@R1               AND Indirect RAM and Acc
      ANL     A,#<immed>          AND Immediate data and Acc
      ANL     A,<direct>          AND Direct RAM and Acc
      ANL     C,/<direct>         AND Complement of direct bit to Carry
      ANL     C,<direct>          AND direct bit to Carry
      ANL     <direct>,A          AND Acc to direct RAM
      ANL     <direct>,#<immed>   AND Immediate data and direct RAM
      
      CJNE    A,#<immed>,<rel>    Compare Immediate to Acc   and JNE
      CJNE    A,<direct>,<rel>    Compare direct RAM to Acc and JNE
      CJNE    Rn,#<immed>,<rel>   Compare Immediate to Register and JNE
      CJNE    @R0,#<immed>,<rel>  Compare Immediate to Indirect RAM and JNE
      CJNE    @R1,#<immed>,<rel>  Compare Immediate to Indirect RAM and JNE
      
      CLR     A                   Clear Accumulator
      CLR     C                   Clear Carry
      CLR     <direct>            Clear Direct RAM

      TASM - Table Driven Assembler                                Page 34  
      
      
      CPL     A                   Complement Accumulator
      CPL     C                   Complement Carry
      CPL     <direct>            Complement Direct RAM
      
      DA      A                   Decimal Adjust Accumulator
      
      DEC     A                   Decrement Acc
      DEC     Rn                  Decrement Register
      DEC     @R0                 Decrement Indirect RAM
      DEC     @R1                 Decrement Indirect RAM
      DEC     <direct>            Decrement Direct RAM
      
      DIV     AB                  Divide Acc by B
      
      DJNZ    Rn,<rel>            Decrement Register and JNZ
      DJNZ    <direct>,<rel>      Decrement Direct RAM and JNZ
      
      INC     A                   Increment Acc
      INC     Rn                  Increment Register
      INC     @R0                 Increment Indirect RAM
      INC     @R1                 Increment Indirect RAM
      INC     DPTR                Increment Data Pointer
      INC     <direct>            Increment Direct RAM
      
      JB      <bit>,<rel>         Jump if Bit is set
      JBC     <bit>,<rel>         Jump if Bit is set & clear Bit
      JC      <rel>               Jump if Carry is set
      JMP     @A+DPTR             Jump indirect relative to Data Pointer
      JNB     <bit>,<rel>         Jump if Bit is clear
      JNC     <rel>               Jump if Carry is clear
      JNZ     <rel>               Jump if Acc is not zero
      JZ      <rel>               Jump if Acc is zero
      
      LCALL   <addr16>            Long Subroutine Call
      LJMP    <addr16>            Long Jump
      
      MOV     A,Rn                Move Register to Acc
      MOV     A,@R0               Move Indirect RAM to Acc
      MOV     A,@R1               Move Indirect RAM to Acc
      MOV     A,#<immed>          Move Immediate data to Acc
      MOV     A,<direct>          Move direct RAM to Acc
      MOV     C,<bit>             Move bit to Acc
      MOV     DPTR,#<immed>       Move immediate data to Data Pointer
      MOV     Rn,A                Move Acc to Register
      MOV     Rn,#<immed>         Move Immediate data to Register
      MOV     Rn,<direct>         Move Direct RAM to Register
      MOV     @R0,A               Move Acc to Indirect RAM
      MOV     @R1,A               Move Acc to Indirect RAM
      MOV     @R0,#<immed>        Move Immediate data to Indirect RAM
      MOV     @R1,#<immed>        Move Immediate data to Indirect RAM
      MOV     @R0,<direct>        Move Direct RAM to Indirect RAM
      MOV     @R1,<direct>        Move Direct RAM to Indirect RAM
      MOV     <direct>,A          Move Acc to Direct RAM
      MOV     <bit>,C             Move Carry to Bit
      MOV     <direct>,Rn         Move Register to Direct RAM
      MOV     <direct>,@R0        Move Indirect RAM to Direct RAM

      TASM - Table Driven Assembler                                Page 35  
      
      MOV     <direct>,@R1        Move Indirect RAM to Direct RAM
      MOV     <direct>,#<immed>   Move Immediate data to Direct RAM
      MOV     <direct>,<direct>   Move Direct RAM to Direct RAM
      MOVC    A,@A+DPTR           Move code byte relative to DPTR to Acc
      MOVC    A,@A+PC             Move code byte relative to PC to Acc
      
      MOVX    A,@R0               Move external RAM to Acc
      MOVX    A,@R1               Move external RAM to Acc
      MOVX    A,@DPTR             Move external RAM to Acc (16 bit addr)
      MOVX    @R0,A               Move Acc to external RAM
      MOVX    @R1,A               Move Acc to external RAM
      MOVX    @DPTR,A             Move Acc to external RAM (16 bit addr)
      
      MUL     AB                  Multiply Acc by B
      
      NOP                         No operation
      
      ORL     A,Rn                OR Register and Acc
      ORL     A,@R0               OR Indirect RAM and Acc
      ORL     A,@R1               OR Indirect RAM and Acc
      ORL     A,#<immed>          OR Immediate data and Acc
      ORL     A,<direct>          OR Direct RAM and Acc
      ORL     C,/<direct>         OR Complement of direct bit to Carry
      ORL     C,<direct>          OR direct bit to Carry
      ORL     <direct>,A          OR Acc to direct RAM
      ORL     <direct>,#<immed>   OR Immediate data and direct RAM
      
      POP     <direct>            Pop  from Stack and put in Direct RAM
      PUSH    <direct>            Push from Direct RAM to Stack
      
      RET                         Return from subroutine
      RETI                        Return from Interrupt
      
      RL      A                   Rotate Acc left
      RLC     A                   Rotate Acc left through Carry
      RR      A                   Rotate Acc right
      RRC     A                   Rotate Acc right through Carry
      
      SETB    C                   Set the Carry Bit
      SETB    <bit>               Set Direct Bit
      
      SJMP    <rel>               Short jump
      
      SUBB    A,Rn                Subtract Register from Acc with Borrow
      SUBB    A,@R0               Subtract Indirect RAM from Acc w/ Borrow
      SUBB    A,@R1               Subtract Indirect RAM from Acc w/ Borrow
      SUBB    A,#<immed>          Subtract Immediate data from Acc w/ Borrow
      SUBB    A,<direct>          Subtract Direct RAM from Acc w/ Borrow
      
      SWAP    A                   Swap nibbles of Acc
      
      XCH     A,Rn                Exchange Acc with Register
      XCH     A,@R0               Exchange Acc with Indirect RAM
      XCH     A,@R1               Exchange Acc with Indirect RAM
      XCH     A,<direct>          Exchange Acc with Direct RAM
      
      XCHD    A,@R0               Exchange Digit in Acc with Indirect RAM

      TASM - Table Driven Assembler                                Page 36  
      
      XCHD    A,@R1               Exchange Digit in Acc with Indirect RAM
      
      XRL     A,Rn                Exclusive OR Register and Acc
      XRL     A,@R0               Exclusive OR Indirect RAM and Acc
      XRL     A,@R1               Exclusive OR Indirect RAM and Acc
      XRL     A,#<immed>          Exclusive OR Immediate data and Acc
      XRL     A,<direct>          Exclusive OR Direct RAM and Acc
      XRL     <direct>,A          Exclusive OR Acc to direct RAM
      XRL     <direct>,#<immed>   Exclusive OR Immediate data and direct RAM
      
      Note  that  the above tables do not automatically define the various
      mnemonics that may be  used  for  addressing  the  special  function
      registers  of  the  8051.  The  user  may  wish  to set up a file of
      equates (EQU's) that can be included in the  source  file  for  this
      purpose.  The following illustrates some of the appropriate equates:
      
      P0      .equ    080H    ;Port 0
      SP      .equ    081H    ;Stack pointer
      DPL     .equ    082H
      DPH     .equ    083H
      PCON    .equ    087H
      TCON    .equ    088H
      TMOD    .equ    089H
      TL0     .equ    08AH
      TL1     .equ    08BH
      TH0     .equ    08CH
      TH1     .equ    08DH
      P1      .equ    090H    ;Port 1
      SCON    .equ    098H
      SBUF    .equ    099H
      P2      .equ    0A0H    ;Port 2
      IEC     .equ    0A8H
      P3      .equ    0B0H    ;Port 3
      IPC     .equ    0B8H
      PSW     .equ    0D0H
      ACC     .equ    0E0H    ;Accumulator
      B       .equ    0F0H    ;Secondary Accumulator
      ;Now some bit addresses
      P0.0    .equ    080H    ;Port 0 bit 0
      P0.1    .equ    081H    ;Port 0 bit 1
      P0.2    .equ    082H    ;Port 0 bit 2
      P0.3    .equ    083H    ;Port 0 bit 3
      P0.4    .equ    080H    ;Port 0 bit 4
      P0.5    .equ    081H    ;Port 0 bit 5
      P0.6    .equ    082H    ;Port 0 bit 6
      P0.7    .equ    083H    ;Port 0 bit 7
      ACC.0   .equ    0E0H    ;Acc bit 0
      ACC.1   .equ    0E1H    ;Acc bit 1
      ACC.2   .equ    0E2H    ;Acc bit 2
      ACC.3   .equ    0E3H    ;Acc bit 3
      ACC.4   .equ    0E4H    ;Acc bit 4
      ACC.5   .equ    0E5H    ;Acc bit 5
      ACC.6   .equ    0E6H    ;Acc bit 6
      Acc.7   .equ    0E7H    ;Acc bit 7
      
      See the manufacturer's data sheets for more information.
      

      TASM - Table Driven Assembler                                Page 37  
      
      
      TASM DISTRIBUTION FILES
      
      TASM  is  distributed  in  two  different  packages  - an executable
      package and a source package.  The files  associated  with  each  of
      these are described below:
      
              EXECUTABLE PACKAGE
              ------------------------------------------------------------
              1.  TASM.EXE          - TASM Assembler, executable
              2.  TASM48.TAB        - 8048 Instruction definition table
              3.  TASM51.TAB        - 8051 Instruction definition table
              4.  TASM65.TAB        - 6502 Instruction definition table
              5.  TASM.DOC          - TASM Documentation
              6.  README            - Brief Explanation of Disk contents
      
              SOURCE PACKAGE
              ------------------------------------------------------------
              1.  TASM.EXE          - TASM Assembler, executable
              2.  TASM48.TAB        - 8048 Instruction definition table
              3.  TASM51.TAB        - 8051 Instruction definition table
              4.  TASM65.TAB        - 6502 Instruction definition table
              5.  TASM.DOC          - TASM Documentation
              6.  README            - Brief Explanation of Disk contents
      
              7.  TASM.C            - TASM mainline source code
              8.  STRLIB.C          - String library
              9.  IOLIB.C           - I/O Library
              10. MACRO.C           - Assembler directive support library
              11. CMAIN.C           - Command line parser
              12. CT.ASM            - MSDOS/C Interface module (startup)
              13. FUNC.ASM          - Assembly language functions
              14. UBYTE.H           - Header file defining unsigned types
              15. TASM.H            - Header file defining TASM constants
              16. TASMBLD.BAT       - Batch file to build TASM.EXE
      
      The  'C'  modules  can  be compiled with the Microsoft 'C' compiler,
      version 2.03  using  the  small  memory  model.  It  should  not  be
      difficult to use other 'C' compilers, however, because no library is
      needed and typical portability problems have been avoided.
      
      The  assembler  files  can  be  assembled  using the Microsoft Macro
      Assembler (MASM) or  equivalent.  The  standard  link  utility  that
      comes  with  MSDOS (Microsoft LINK) can be used to perform the link.
      The TASMBLD.BAT file demonstrates  steps  necessary  for  compiling,
      assembling and linking.
      
      
      
      
      
      
      
      
      
      
      

      TASM - Table Driven Assembler                                Page 38  
      
      
      PORTING TASM TO OTHER ENVIRONMENTS
      
      TASM source code is fairly portable.  We,  however, have only tested
      it in two environments,  Berkeley UNIX (BSD 4.2) and MSDOS 2.1 (UNIX
      is  a  trademark  of  AT&T,  MSDOS  is  a  trademark  of Microsoft).
      Portability is enhanced by:
      
              1.  All identifiers are unique to 6 characters.
              2.  No floating point arithmetic.
              3.  No Long (32 bit) arithmetic.
              4.  No bit fields.
              5.  Self contained code (no library routines are necessary).
      
      
      It  should  be  noted that a number of the modules that are included
      with TASM are not  necessary  in  some  other  environments  because
      identical  facilities  are  part of the standard library.  TASM does
      not use any libraries from other vendors (including the Microsoft  C
      library  that comes with the compiler that was used to compile TASM)
      to ensure  no  copyrights  are  violated.  The  modules  that  would
      generally not be needed include:
      
              1.  iolib.c     This includes read(), write(), open(),
                                  close(), sprintf(), etc.
              2.  strlib.c    This includes strcpy(), strcmp(), isdigit(),
                                  isalnum(), etc.
              3.  cmain.c     Parses command line into argc, argv format.
              4.  ct.asm      Interface between MSDOS and Microsoft C.
              5.  func.asm    Peek and poke functions.
      
      
      For example, the following command can be used to make an executable
      version of TASM for the BSD 4.2 environment:
      
              %cc -DUNIX tasm.c macro.c  -o tasm
      
      The header files tasm.h and ubyte.h should also be available.
      
      Note  that the UNIX flag is being defined on the command line.  This
      causes the following things to happen:
      
              1.   Unsigned   word   and   byte   typedefs   are   defined
                      appropriately (Microsoft C 2.03  is  nonstandard  in
                      this respect).
      
              2.  Tasm.h includes sys/file.h instead of defining  its  own
                      file open constants.
      
              3.  TASM declares a 64 Kbyte array  in  which  to  hold  the
                      assembled   opcodes   and   data.   In   the   MSDOS
                      environment a 64 Kbyte segment is  used  immediately
                      following  the stack segment to hold the opcodes and
                      data.  This is done so a small  data  model  can  be
                      used  by  the compiler (since many compilers for the
                      MSDOS environment do not have  any  other  option  -
                      done  for  portability  to other MSDOS C compilers).

      TASM - Table Driven Assembler                                Page 39  
      
                      In the BSD UNIX environment,  64 Kbyte arrays are no
                      problem,  and  if you are porting the code to a like
                      environment (whether UNIX or not), the UNIX flag may
                      be  useful.   This  eliminates  calls   to   several
                      assembly   language  routines  defined  in  func.asm
                      (peekb, pokeb, and getsegs).  Also,  if you are only
                      interested  in  the 8048 version,  which really only
                      needs a  4  Kbyte  memory  space,  the  local  array
                      approach  would  suffice  and eliminate the need for
                      the assembly language calls.
      
      
      For information on building TASM in the MSDOS environment,  see  the
      TASMBLD.BAT file.
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      

      TASM - Table Driven Assembler                                Page 40  
      
      
      TASM INSTRUCTION SET TABLE DEFINITION
      
      The tables that control TASM's interpretation of the source file are
      read from a file at run time.  The table file name is determined  by
      taking  the  numeric option field specified on the TASM command line
      and appending it to the string "TASM", then a  ".TAB"  extension  is
      added.  Thus, if the following command line is entered:
      
              tasm -51  test.asm
      
      then TASM would read the table file named "TASM51.TAB".
      
      
      
      The following rules apply to the structure of the table file:
      
              1.  The  first  line  of  the  file  should contain a string
                      surrounded by double quotes that should identify the
                      version of the assembler  table.  This  string  will
                      appear at the top of each page in the list file.  It
                      should be limited to 24 characters.
      
              2.  Any  line  whose  first  character  is not alphabetic is
                      considered to be a comment and is discarded.
      
              3.  Any  line  that has an alphabetic character as the first
                      character is assumed to be an instruction definition
                      record  and  is  parsed  to   build   the   internal
                      representation  of the instruction set tables.   Six
                      fields (separated by white space) are  expected,  as
                      follows:
      
                      Field Name      Description
                      --------------------------------------------
                      INSTRUCTION     Instruction Mnemonic
                      ARGS            Argument definition
                      OPCODE          Opcode value
                      NBYTES          Number of bytes
                      MODOP           Modifier operation
                      CLASS           Instruction class
      
      
                      INSTRUCTION.  The  INSTRUCTION  field should contain
                      the string to be  used  as  the  mnemonic  for  this
                      instruction.  Upper case letters should be used (the
                      source statements are converted to upper case before
                      comparison).
      
      
                      ARGS.   The  ARGS  field  should  contain  a  string 
                      describing  the  format  of  the operand field.  All 
                      characters are taken literally except the '*'  which 
                      denotes  the  presence  of  a valid TASM expression.  
                      Multiple '*'s can be used,  but all but the last one 
                      must  be  followed  by  a  comma.  If  a  single '*' 
                      appears in the ARGS field,  then the default  action 

      TASM - Table Driven Assembler                                Page 41  
      
                      of  TASM  will  be  to  determine  the  value of the 
                      expression that matches the field and insert one  or 
                      two  bytes  of  it into the object file depending on 
                      the NBYTES field.  If multiple '*'s are  used,  then 
                      special  operators  (MODOP)  must  be  used  to take 
                      advantage of them (see the examples below).  An ARGS 
                      field of a pair  of  double  quotes  means  that  no 
                      arguments are expected.  
      
      
                      OPCODE.  The OPCODE field should contain the  opcode
                      value  (two  hex  digits)  for  this instruction and
                      address mode.
      
      
                      NBYTES.  The NBYTES field should specify the  number
                      of  bytes  this  instruction  is to occupy (a single
                      decimal digit).
      
      
                      MODOP.  The MODOP field determines  if  any  special
                      operations   need   to  be  performed  on  the  code
                      generated for this  instruction.  For  example,  the
                      zero-page  addressing  mode of the 6502 is a special
                      case of the absolute addressing mode, and is handled
                      by a special MODOP code (see appendix B).  The  list
                      of operators is as follows:
      
      
                      MODOP       DESCRIPTION
                      ---------------------------------------------------
                      NOTOUCH     Do nothing to instruction or args
                      JMPPAGE     Put bits 8-10 of first arg into
                                  bits 5-7 of opcode (8048 JMP)
                      ZPAGE       If arg < 256 then use zero-page (6502)
                      R1          Make arg relative to PC (single byte)
                      R2          Make arg relative to PC (two byte)
                      CREL        Combine LS bytes of first two args
                                  making the second one relative to PC
                      SWAP        Swap bytes of first arg
                      COMBINE     Combine LS bytes of first two args into
                                  first arg (arg1 -> LSB, arg2 ->MSB).
                      CSWAP       Combine LS bytes of first two args into
                                  first arg and swap.
      
                      Note  that the reason for the combining of arguments 
                      (COMBINE and CSWAP) is that TASM  assumes  that  all 
                      object  bytes  to be inserted in the object file are 
                      derived from a variable representing  the  value  of 
                      the  first  argument (argval).  If two arguments are 
                      in the  ARGS  field,  then  one  of  the  previously 
                      mentioned  MODOP`s  must  be  used.  They  have  the 
                      effect of combining the low bytes of the  first  two 
                      arguments  into the variable (argval) from which the 
                      object  code  will  be  generated.  TASM`s  argument 
                      parsing   routine  can  handle  a  large  number  of 
                      arguments,  but the code that generates  the  object 

      TASM - Table Driven Assembler                                Page 42  
      
                      code is less capable.  
      
                      CLASS.  The  CLASS  field is used to specify whether
                      this instruction is part of the standard instruction
                      set or a member of a set of  extended  instructions.
                      Bit 0 of this field should be set to denote a member
                      of  the standard instruction set.  Other bits can be
                      used as needed  to  establish  several  classes  (or
                      sets)   of  instructions  that  can  be  enabled  or
                      disabled via  the  '-x'  command  line  option  (see
                      section on 6502 INSTRUCTIONS AND ADDRESSING MODES).
      
      
      For  example  the  following  table   shows   possible   instruction
      definition  records,  followed  by  possible  source statements that
      would match it,  followed by the resulting object code that would be
      generated (in hex):
                                                      EXAMPLE
      INSTRUCTION DEFINITION                  SOURCE          OBJECT
      -------------------------------------------------------------------
      XYZ  *     FF  3  NOTOUCH 1             xyz 1234h       FF 34 12
      XYZ  *     FF  2  NOTOUCH 1             xyz 1234h       FF 34
      ZYX  *     FE  3  SWAP    1             zyx 1234h       FE 12 34
      ZYX  *     FE  3  R2      1             zyx $+4         FE 01 00
      ABC  *,*   FD  3  COMBINE 1             abc 45h,67h     FD 45 67
      ABC  *,*   FD  3  CSWAP   1             abc 45h,67h     FD 67 45
      ADD  A,#*  FC  2  NOTOUCH 1             add A,#'B'      FC 42
      RET  ""    FB  1  NOTOUCH 1             ret             FB
      
      See appendix B for more examples.
      
      The  order  of  the  entries for various addressing modes of a given 
      instruction is important.  Since the wild card matches anything,  it 
      is  important to specify the ARGS for the addressing modes that have 
      the  most  qualifying  characters  first.   For   example,   if   an 
      instruction  had  two  addressing  modes,   one  that  accepted  any 
      expression,  and another that required a pound sign in front  of  an 
      expression,  the  pound  sign  entry  should  go first otherwise all 
      occurrences of the instruction would match  the  more  general  ARGS 
      expression   that  it  encountered  first.   The  following  entries 
      illustrate the proper sequencing: 
      
              ADD #*  12 3 NOTOUCH 1
              ADD *   13 3 NOTOUCH 1
      
      
      
      
      
      
      
      
      
      
      
      
      

      TASM - Table Driven Assembler                                Page 43  
      
      
      SUMMARY
      --------------------------------------------------------------------------------------------------------------------------
      COMMAND LINE:                                               | DIRECTIVES:
        tasm -vv [-bcfhlmpxdo] source_file [obj_file [list_file]] |   #INCLUDE <filename> Read <filename> as source
                                                                  |   #DEFINE  <label> [<macro_def>] Define a macro
        -<vv>   Select version (-48, -51, or -65)                 |   #IFDEF   <label>    Assemble following if <label> DEFINEd
        -o<nn>  Specify number of obj bytes per record (hex)      |   #IFNDEF  <label>    Assemble following if <label> not DEFd
        -c      object file written as a contiguous block         |   #IF      <expr>     Assemble following if <expr> nonzero
        -d<mac> define a macro                                    |   #ELSE               Alternate block to assemble
        -f<xx>  Fill entire memory space with <xx> (hex)          |   #ENDIF              End of conditional block
        -h      Produce hex table of the assembled code           |   .ORG     <expr>     Set Instruction Pointer
        -l      Produce a label table in the listing              |   .BYTE    <expr>     Define a byte
        -m      Produce object in MOS Technology format           |   .WORD    <expr>     Define a word (lsb, msb)
        -b      Produce object in binary (.COM) format            |   .EQU     <expr>     Assign a value to label
        -p      Page the listing file                             |   .TEXT    <string>   Define bytes as ASCII characters
        -x<m>   Enable extended instruction set (m = class mask)  |   .BLOCK   <expr>     Block space reserve
        -q      Quite, disable listing file                       |   .TITLE   <string>   Set a title to appear on listing
      ------------------------------------------------------------|   .EJECT              Do Top of Form on listing
      OPERATORS:                                                  |   .LIST               Turn listing on
        Operator  Type          Description                       |   .NOLIST             Turn listing off
        __________________________________________                |   .PAGE               Turn paging on
        +        Additive       addition                          |   .NOPAGE             Turn paging off
        -                       subtraction                       |   .ADDINSTR <instdef> Add instruction
        *        Multiplicative multiplication                    |   .END                End of source code
        /                       division                          |   =        <expr>     Alternate form of EQU
        %                       modulo                            |   *=       <expr>     Alternate form of ORG
        <<                      logical shift left                |------------------------------------------------------
        >>                      logical shift right               | CONSTANTS:
        ~        Unary          bit inversion (one's complement)  |   Numeric constants: <digits><suffix>
        -                       unary negation                    |     <digits> = digit string taken from (0-9,a-f,A-F)
        =        Relational     equal                             |     <suffix> = radix indicator defined as follows:
        ==                      equal                             |
        !=                      not equal                         |     Suffix              Radix
        <                       less than                         |     ------------------------
        >                       greater than                      |     b or B               2   (or % prefix)
        <=                      less than or equal                |     o or O               8   (or @ prefix)
        >=                      greater than or equal             |     d or D (or nothing)  10
        &       Binary          binary 'and'                      |     h or H               16  (or $ prefix)
        |                       binary 'or'                       |
        ^                       binary 'exclusive or'             |   Character constants: '<char>' (printable ASCII
      Note: 16 bit values used.  Relational Ops yield 1 or 0.     |                         character surrounded by single
                                                                  |                         quotes, e.g. 'a'.
                                                                  |
      ------------------------------------------------------------|   String constants: "<characters>" (printable ASCII
      NOTES:                                                      |                      characters surrounded by double
       1. Statement format:<label> <operation> <operand> <comment>|                      quotes, e.g. "This is a string".
       2. The backslash can be used to separate multiple          |                      Used only for TEXT and TITLE.
              statements on a line (e.g. lda byte1 \ sta byte2).  |
       3. '$' or '*' represent the current Instruction Counter.   |
       4. Comments preceded by semicolon (';').                   |
       5. TASM is case insensitive for mnemonics, but not labels. |
       6. The default object file format is Intel Hex.            |
       7. For 6502 version -x3 option enables R65C02 instructions |
              and -x5 enables R65C00/21 instructions.             |
      --------------------------------------------------------------------------------------------------------------------------
      

      TASM - Table Driven Assembler                                Page 44  
      
      
      APPENDIX A - SAMPLE LISTING FILE
      
      The listing was generated by issuing the command:
              tasm -65 -p -l -h -f00 t.asm
      
      TASM 6502 Assembler.            t.asm                         page 1
      Speech Technology Incorporated.
      
      0001   0000             ;This is a simple example of an assembly
      0002   0000             ;include a file just for fun
      0003   0000             #include        "include.h"
      0001+  0000             ;this is just a simple include file
      0002+  0000             exit    .equ    7e00h
      0003+  0000             ;
      0004+  0000             ; That's all
      0004   0000             ;
      0005   0000             ; define two byte increment macro
      0006   0000             #define INCZ(p) ldx #p\ inc 0,x\ bne $+4\ inc 1,x
      0007   0000             ;
      0008   0000             start   .org    $0
      0009   0000             mask    .equ    $5678
      0010   0000
      0011   0000 0A          byte1   .byte   10
      0012   0001 D2 04       word1   .word   1234
      0013   0003 34 12       word2   .word   $1234
      0014   0005             ;skip past a few locations to start code
      0015   0020                     .org    $0020
      0016   0020             begin
      0017   0020             ;     let's just increment word1 the number
      0018   0020             ;     of times indicated by byte1 (use the
      0019   0020             ;     double byte increment macro INCZ).
      0020   0020             loop1
      0021   0020 A2 01               ldx #word1\ inc 0,x\ bne $+4\ inc 1,x
      0021   0022 F6 00
      0021   0024 D0 02
      0021   0026 F6 01
      0022   0028 C6 00               dec     byte1   ;decrement the count
      0023   002A D0 F4               bne     loop1   ;loop until zero
      0024   002C
      0025   002C             ; Now  let's just do some simple arithmetic
      0026   002C A5 56               lda     (mask >> 8)
      0027   002E AD 00 56            lda     (mask & 0ff00h)
      0028   0031 A5 57               lda     ((mask >> 8) & 0ffh) + word1
      0029   0033 4C 00 7E            jmp     exit
      0030   0036                     .end
      
      
      
      
      
      
      
      
      
      
      

      TASM - Table Driven Assembler                                Page 45  
      
      
      
      Label        Value      Label        Value      Label        Value
      ------------------      ------------------      ------------------
      exit          7E00      start         0000      mask          5678
      byte1         0000      word1         0001      word2         0003
      begin         0020      loop1         0020
      
      ADDR  00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F
      -----------------------------------------------------
      0000  0A D2 04 34 12 00 00 00 00 00 00 00 00 00 00 00
      0010  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
      0020  A2 01 F6 00 D0 02 F6 01 C6 00 D0 F4 A5 56 AD 00
      0030  56 A5 57 4C 00 7E 00 00 00 00 00 00 00 00 00 00
      
      tasm: Number of errors = 0
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      

      TASM - Table Driven Assembler                                Page 46  
      
      
      APPENDIX B - SAMPLE INSTRUCTION DEFINITION TABLE (TASM65.TAB)
      
      "TASM 6502 Assembler.    "
      /* This is the instruction set definition table
      /*   for the 6502 version of TASM.
      /*      Thomas N. Anderson, Speech Technology Incorporated, Feb 1986.
      /*  First line of this file is a banner that will appear at the
      /*  top of each page of the TASM listing file (not the same as
      /*  the TITLE).  Should be limited to 24 characters.
      /*  Any other line that does not start with an upper case letter is
      /*  ignored.
      /*  See TASM manual for info on table structure.
      /*  Note that there are two classes of extended instructions beyond
      /*    the standard set.  The classes are assigned bits as follows:
      /*      bit 0 = standard set
      /*      bit 1 = extended instructions for R65C02
      /*      bit 2 = extended instructions for R65C00/21
      /*
      /*INSTR ARGS OPCODE BYTES MOD CLASS */
      /*----------------------------------*/
      ADC  #*     69    2  NOP 1
      ADC  (*,X)  61    2  NOP 1
      ADC  (*),Y  71    2  NOP 1
      ADC  (*)    72    2  NOP 2   /* R65C02 */
      ADC  *,X    7D    3  ZP  1
      ADC  *,Y    79    3  NOP 1
      ADC  *      6D    3  ZP  1
      
      AND  #*     29    2  NOP 1
      AND  (*,X)  21    2  NOP 1
      AND  (*),Y  31    2  NOP 1
      AND  (*)    32    2  NOP 2   /* R65C02 */
      AND  *,X    3D    3  ZP  1
      AND  *,Y    39    3  NOP 1
      AND  *      2D    3  ZP  1
      
      ASL  A      0A    1  NOP 1
      ASL  *,X    1E    3  ZP  1
      ASL  *      0E    3  ZP  1
      
      BCC  *      90    2  R1  1
      BCS  *      B0    2  R1  1
      BEQ  *      F0    2  R1  1
      BNE  *      D0    2  R1  1
      BMI  *      30    2  R1  1
      BPL  *      10    2  R1  1
      BVC  *      50    2  R1  1
      BVS  *      70    2  R1  1
      
      BIT  #*     89    2  NOP 2
      BIT  *,X    3C    3  ZP  2
      BIT  *      2C    3  ZP  1
      
      BRK  ""     00    1  NOP 1
      
      CLC  ""     18    1  NOP 1

      TASM - Table Driven Assembler                                Page 47  
      
      CLD  ""     D8    1  NOP 1
      CLI  ""     58    1  NOP 1
      CLV  ""     B8    1  NOP 1
      
      CMP  #*     C9    2  NOP 1
      CMP  (*,X)  C1    2  NOP 1
      CMP  (*),Y  D1    2  NOP 1
      CMP  (*)    D2    2  NOP 2
      CMP  *,X    DD    3  ZP  1
      CMP  *,Y    D9    3  NOP 1
      CMP  *      CD    3  ZP  1
      
      CPX  #*     E0    2  NOP 1
      CPX  *      EC    3  ZP  1
      
      CPY  #*     C0    2  NOP 1
      CPY  *      CC    3  ZP  1
      
      DEC  A      3A    3  NOP 2
      DEC  *,X    DE    3  ZP  1
      DEC  *      CE    3  ZP  1
      
      DEX  ""     CA    1  NOP 1
      DEY  ""     88    1  NOP 1
      
      EOR  #*     49    2  NOP 1
      EOR  (*,X)  41    2  NOP 1
      EOR  (*),Y  51    2  NOP 1
      EOR  (*)    52    2  NOP 2
      EOR  *,X    5D    3  ZP  1
      EOR  *,Y    59    3  NOP 1
      EOR  *      4D    3  ZP  1
      
      INC  A      1A    3  NOP 2
      INC  *,X    FE    3  ZP  1
      INC  *      EE    3  ZP  1
      
      INX  ""     E8    1  NOP 1
      INY  ""     C8    1  NOP 1
      
      JMP  (*,X)  7C    3  NOP 2
      JMP  (*)    6C    3  NOP 1
      JMP  *      4C    3  NOP 1
      
      JSR  *      20    3  NOP 1
      
      LDA  #*     A9    2  NOP 1
      LDA  (*,X)  A1    2  NOP 1
      LDA  (*),Y  B1    2  NOP 1
      LDA  (*)    B2    2  NOP 2
      LDA  *,X    BD    3  ZP  1
      LDA  *,Y    B9    3  NOP 1
      LDA  *      AD    3  ZP  1
      
      LDX  #*     A2    2  NOP 1
      LDX  *,Y    BE    3  ZP  1
      LDX  *      AE    3  ZP  1

      TASM - Table Driven Assembler                                Page 48  
      
      
      LDY  #*     A0    2  NOP 1
      LDY  *,X    BC    3  ZP  1
      LDY  *      AC    3  ZP  1
      
      LSR  A      4A    1  NOP 1
      LSR  *,X    5E    3  ZP  1
      LSR  *      4E    3  ZP  1
      
      NOP  ""     EA    1  NOP 1
      
      ORA  #*     09    2  NOP 1
      ORA  (*,X)  01    2  NOP 1
      ORA  (*),Y  11    2  NOP 1
      ORA  (*)    12    2  NOP 2
      ORA  *,X    1D    3  ZP  1
      ORA  *,Y    19    3  NOP 1
      ORA  *      0D    3  ZP  1
      
      PHA  ""     48    1  NOP 1
      PHP  ""     08    1  NOP 1
      PLA  ""     68    1  NOP 1
      PLP  ""     28    1  NOP 1
      
      ROL  A      2A    1  NOP 1
      ROL  *,X    3E    3  ZP  1
      ROL  *      2E    3  ZP  1
      
      ROR  A      6A    1  NOP 1
      ROR  *,X    7E    3  ZP  1
      ROR  *      6E    3  ZP  1
      
      RTI  ""     40    1  NOP 1
      RTS  ""     60    1  NOP 1
      
      SBC  #*     E9    2  NOP 1
      SBC  (*,X)  E1    2  NOP 1
      SBC  (*),Y  F1    2  NOP 1
      SBC  (*)    F2    2  NOP 2
      SBC  *,X    FD    3  ZP  1
      SBC  *,Y    F9    3  NOP 1
      SBC  *      ED    3  ZP  1
      
      SEC  ""     38    1  NOP 1
      SED  ""     F8    1  NOP 1
      SEI  ""     78    1  NOP 1
      
      STA  (*,X)  81    2  NOP 1
      STA  (*),Y  91    2  NOP 1
      STA  (*)    92    2  NOP 2
      STA  *,X    9D    3  ZP  1
      STA  *,Y    99    3  NOP 1
      STA  *      8D    3  ZP  1
      
      STX  *,Y    96    2  ZP  1
      STX  *      8E    3  ZP  1
      

      TASM - Table Driven Assembler                                Page 49  
      
      STY  *,X    94    2  NOP 1
      STY  *      8C    3  ZP  1
      
      TAX  ""     AA    1  NOP 1
      TAY  ""     A8    1  NOP 1
      TSX  ""     BA    1  NOP 1
      TXA  ""     8A    1  NOP 1
      TXS  ""     9A    1  NOP 1
      TYA  ""     98    1  NOP 1
      
      /* Here are the extended instructions that are totally new */
      
      BRA  *      80    2  R1  6
      
      BBR0 *,*    0f    3  CR  6
      BBR1 *,*    1f    3  CR  6
      BBR2 *,*    2f    3  CR  6
      BBR3 *,*    3f    3  CR  6
      BBR4 *,*    4f    3  CR  6
      BBR5 *,*    5f    3  CR  6
      BBR6 *,*    6f    3  CR  6
      BBR7 *,*    7f    3  CR  6
      
      BBS0 *,*    8f    3  CR  6
      BBS1 *,*    9f    3  CR  6
      BBS2 *,*    af    3  CR  6
      BBS3 *,*    bf    3  CR  6
      BBS4 *,*    cf    3  CR  6
      BBS5 *,*    df    3  CR  6
      BBS6 *,*    ef    3  CR  6
      BBS7 *,*    ff    3  CR  6
      
      MUL  ""     02    1  NOP 4  /* R65C00/21 only*/
      
      PHX  ""     da    1  NOP 6
      PHY  ""     5a    1  NOP 6
      PLX  ""     fa    1  NOP 6
      PLY  ""     7a    1  NOP 6
      
      RMB0 *      07    2  NOP 6
      RMB1 *      17    2  NOP 6
      RMB2 *      27    2  NOP 6
      RMB3 *      37    2  NOP 6
      RMB4 *      47    2  NOP 6
      RMB5 *      57    2  NOP 6
      RMB6 *      67    2  NOP 6
      RMB7 *      77    2  NOP 6
      
      SMB0 *      87    2  NOP 6
      SMB1 *      97    2  NOP 6
      SMB2 *      a7    2  NOP 6
      SMB3 *      b7    2  NOP 6
      SMB4 *      c7    2  NOP 6
      SMB5 *      d7    2  NOP 6
      SMB6 *      e7    2  NOP 6
      SMB7 *      f7    2  NOP 6
      

      TASM - Table Driven Assembler                                Page 50  
      
      /* The following extended instructions are available on the
              R65C02 but not the R65C00/21 */
      
      STZ  *,X    9e    3  ZP  2
      STZ  *      9c    3  ZP  2
      
      TRB  *      1c    3  ZP  2
      TSB  *      0c    3  ZP  2
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      

      TASM - Table Driven Assembler                                Page 51  
      
      
      APPENDIX C - ORDERING INFORMATION
      
      TASM  is  distributed as shareware.  If you find it useful,  you are 
      encouraged to become a registered  user.  Registered  users  receive 
      the following benifits: 
                  
              1.  The recent version of TASM.
              2.  TASM source code (in C).
              3.  Bound TASM manual.
              4.  Knowledge that they are supporting  the  development  of 
                      useful but inexpensive software.  
      
      DESCRIPTION                     UNIT PRICE      QUANTITY      PRICE
      --------------------------------------------------------------------
      
      TASM Registration                    30.00      ________     _______
      
      TASM User's Manual (included above)  10.00      ________     _______
      
      
      Subtotal                                                     _______
      
      
      Tax (Washington state residents add 7.9%)                    _______
      
      
      TOTAL (post paid)                                            _______
      
      
      
      Shipping Address:
      
      ______________________________________________
      
      ______________________________________________
      
      ______________________________________________
      
      
      
      Send check or money order (no credit cards) to:
      
                      Speech Technology Incorporated
                      16321 176th Avenue NE
                      Woodinville, WA  98072
      
      
      
      
      
      
      
      
      
      
      
